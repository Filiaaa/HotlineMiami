# Сравнение стеков на массиве и списке

Эта программа сравнивает скорость работы стека на динамическом массиве и стека на списке

## Немного теории:

1. **Стек на динамическом массиве**:

\section{Стек на динамическом массиве}

\subsection{Структура}
Стек реализован на динамическом массиве с автоматическим изменением размера:
\begin{itemize}
    \item \texttt{data} — указатель на массив элементов
    \item \texttt{capacity} — текущая вместимость
    \item \texttt{size} — количество элементов
    \item \texttt{element\_size} — размер элемента в байтах
\end{itemize}

\subsection{Операции}
\begin{tabular}{|l|l|l|}
\hline
\textbf{Операция} & \textbf{Сложность} & \textbf{Описание} \\
\hline
\texttt{push} & $O(1)$ (аморт.) & Добавление элемента в вершину \\
\hline
\texttt{pop} & $O(1)$ (аморт.) & Удаление элемента из вершины \\
\hline
\texttt{top} & $O(1)$ & Чтение вершины без удаления \\
\hline
\texttt{resize} & $O(n)$ & Редкая операция изменения размера \\
\hline
\end{tabular}

\subsection{Амортизационный анализ}
При операциях \texttt{push/pop} стек может изменить размер массива:

\begin{enumerate}
    \item \textbf{Расширение} (при \texttt{size == capacity}):
    \begin{itemize}
        \item Новый размер: $capacity_{new} = 2 \times capacity_{old}$
        \item Стоимость: $O(n)$ (копирование всех элементов)
    \end{itemize}

    \item \textbf{Сжатие} (при \texttt{size < capacity/4}):
    \begin{itemize}
        \item Новый размер: $capacity_{new} = capacity_{old}/2$
        \item Стоимость: $O(n)$
    \end{itemize}
\end{enumerate}

\subsubsection*{Метод потенциалов}
Введём потенциал $\Phi$ после $i$-й операции:
\[
\Phi(D_i) = 
\begin{cases}
2 \times size_i - capacity_i & \text{если } size_i > capacity_i/2 \\
capacity_i/2 - size_i & \text{иначе}
\end{cases}
\]

\begin{itemize}
    \item \textbf{Перед расширением}: $\Phi_{before} = n$ (т.к. $size = capacity$)
    \item \textbf{После расширения}: $\Phi_{after} = 2$ (т.к. $size = n$, $capacity = 2n$)
    \item \textbf{Амортизированная стоимость}:
    \[
    \hat{c}_i = c_i + \Phi_{after} - \Phi_{before} = n + 2 - n = 2 = O(1)
    \]
\end{itemize}

Аналогично доказывается для операций \texttt{pop} и сжатия.

\subsection{Итог}
\begin{itemize}
    \item Средняя стоимость \texttt{push/pop} = $O(1)$
    \item Память: $O(n)$ (не более чем в 4 раза больше элементов)
    \item Локальность данных: высокая (элементы в массиве хранятся последовательно)
\end{itemize}

## Как запустить?
1. chmod +x script.sh
2. ./script.sh

## Tests

1. **Тест 1**:
   - Добаввить 1,000,000 чисел в стек.
   - Удалить половину и добавить четверть (750,000 элементов осталось).
   - Повторять пока не останется меньше 100,000 элементов (9 раз всего).

2. **Тест 2**:
   - Добавить 1,000,000 чисел в стек.
   - Удалить 10,000 элементов и добавить обратно 10,000 чисел, 100 раз.
   - Совершить те же действия, что и в тесте 1 (9 раз).
   - Удалить и добавить 10,000 чисел, 100 раз.

3. **Test 3**:
   - Сгенировать рандомные числа (1 или 2).
   - Добавить 1,000,000 таких чисел.
   - Выполнить 1,000,000 действий: добавить число (1 или 2), если "выпало" 1, удалить элемент, если "выпало" 2.
   - Время начинаем измерять после добавления 1,000,000 чисел.

## Итоги тестов:

| Тип стека  | Тест 1 Время | Тест 2 Время | Тест 3 Время |
|------------|--------------|--------------|--------------|
| Array      | 0.025496     | 0.048098     | 0.042529     |
| List       | 0.060666     | 0.11762      | 0.039192     |

## График

График зависимости времени работы стека от количества элементов

![Non graph image](img/graph1.png)

## Вывод

Стек на динамическом массиве гораздо быстрее стека на списке, ввиду того, что элемента массива хранятся в непрерывной области памяти, т.е. он "cash friendly", а элементы списка "разбросаны".
